import { describe, it, before, beforeEach } from "node:test"
import assert from "node:assert/strict"
import FS from "@nan0web/db-fs"
import {
	DatasetParser,
	DocsParser,
	runSpawn,
} from "@nan0web/test"
import {
	Logger as BaseLogger,
	NoConsole,
	NoLogger as BaseNoLogger,
} from "./index.js"

class Logger extends BaseLogger {
	constructor(options = {}) {
		if ("string" === typeof options) {
			options = { level: options }
		}
		super({ ...options, console: new NoConsole({ silent: false }) })
	}
	get isTTY() {
		return true
	}
	write(str) {
		this.console.info(str)
	}

	/**
	 * Returns captured logs with preserved structure.
	 * @param {string | Function | null} type The type to filter
	 * @returns {Array<Array<string, any[]>>}
	 */
	output(type = null) {
		return this.console.console.output(type)
	}
}

class NoLogger extends BaseNoLogger {
	get isTTY() {
		return false
	}
}

const fs = new FS()
let pkg

// Load package.json once before tests
before(async () => {
	const doc = await fs.loadDocument("package.json", {})
	pkg = doc || {}
})

let console = new NoConsole()

beforeEach((info) => {
	console = new NoConsole()
})

/**
 * Core test suite that also serves as the source for README generation.
 *
 * The block comments inside each `it` block are extracted to build
 * the final `README.md`. Keeping the comments here ensures the
 * documentation stays close to the code.
 */
function testRender() {
	/**
	 * @docs
	 * # @nan0web/log
	 *
	 * <!-- %PACKAGE_STATUS% -->
	 *
	 * A cross-platform Logger class that wraps console methods for both Node.js and browsers
	 * with consistent interface and streaming support.
	 *
	 * ## Description
	 *
	 * The `@nan0web/log` package provides a minimal yet powerful foundation for logging systems.
	 * Core classes:
	 *
	 * - `Logger` ‚Äî main logger class with levels, icons, colors, time and streaming support
	 * - `LogConsole` ‚Äî wraps console methods for consistent cross-platform logging
	 * - `LoggerFormat` ‚Äî defines format for a logger level with icon, color and background
	 * - `NoLogger` ‚Äî captures logs in memory, perfect for testing
	 * - `NoConsole` ‚Äî captures console output in memory, perfect for testing
	 *
	 * These classes are perfect for building CLI tools, debugging layers, structured logs,
	 * and streaming data to files or external services.
	 *
	 * ## Installation
	 */
	it("How to install with npm?", () => {
		/**
		 * ```bash
		 * npm install @nan0web/log
		 * ```
		 */
		assert.equal(pkg.name, "@nan0web/log")
	})
	/**
	 * @docs
	 */
	it("How to install with pnpm?", () => {
		/**
		 * ```bash
		 * pnpm add @nan0web/log
		 * ```
		 */
		assert.equal(pkg.name, "@nan0web/log")
	})
	/**
	 * @docs
	 */
	it("How to install with yarn?", () => {
		/**
		 * ```bash
		 * yarn add @nan0web/log
		 * ```
		 */
		assert.equal(pkg.name, "@nan0web/log")
	})

	/**
	 * @docs
	 * ## Usage
	 *
	 * ### Basic Logger
	 *
	 * Logger can be instantiated with a level or options and logs everything below that level
	 */
	it("How to create a Logger instance with level?", () => {
		//import Logger from '@nan0web/log'
		const logger = new Logger('debug')
		logger.info(typeof logger.debug) // ‚Üê function
		logger.info(logger.level) // ‚Üê debug
		assert.equal(logger.output()[0][1], 'function')
		assert.equal(logger.output()[1][1], 'debug')
	})
	/**
	 * @docs
	 */
	it("How to create a Logger instance with options?", () => {
		//import Logger from '@nan0web/log'
		const logger = new Logger({
			level: 'info',
			icons: true,
			chromo: true,
			time: true,
		})
		logger.info("Hello with options") // ‚Üê TIME-HH-IIT... ‚Ñπ Hello with options
		assert.ok(logger)
		const output = logger.output()[0][1]
		assert.ok(output.endsWith(" ‚Ñπ Hello with options"))
		assert.ok(output.match(/^\d{4}-\d{2}-\d{2}T/))
	})

	/**
	 * @docs
	 * ### Custom Formats
	 *
	 * Logger supports custom formats for different levels
	 */
	it("How to use custom formats for different levels?", () => {
		//import Logger from '@nan0web/log'
		const logger = new Logger({
			level: "debug",
			icons: true,
			formats: [
				["debug", { icon: "üîç", color: Logger.CYAN }],
				["info", { icon: "‚ÑπÔ∏è ", color: Logger.GREEN }],
				["warn", { icon: "‚ö†Ô∏è ", color: Logger.YELLOW }],
				["error", { icon: "‚ùå", color: Logger.RED }],
				["success", { icon: "‚úÖ", color: Logger.GREEN }],
			]
		})
		logger.debug("Debug message")     // ‚Üê \x1b[36müîç Debug message\x1b[0m
		logger.info("Info message")       // ‚Üê \x1b[32m‚ÑπÔ∏è  Info message\x1b[0m
		logger.warn("Warning message")    // ‚Üê \x1b[33m‚ö†Ô∏è  Warning message\x1b[0m
		logger.error("Error message")     // ‚Üê \x1b[31m‚ùå Error message\x1b[0m
		logger.success("Success message") // ‚Üê \x1b[32m‚úÖ Success message\x1b[0m
		assert.ok(logger)
		const logs = logger.output()
		assert.deepStrictEqual(logs, [
			["debug", "\x1b[36müîç Debug message\x1b[0m"],
			["info", "\x1b[32m‚ÑπÔ∏è  Info message\x1b[0m"],
			["warn", "\x1b[33m‚ö†Ô∏è  Warning message\x1b[0m"],
			["error", "\x1b[31m‚ùå Error message\x1b[0m"],
			["info", "\x1b[32m‚úÖ Success message\x1b[0m"],
		])
		assert.ok(logs[0][1].includes("üîç"))
		assert.ok(logs[1][1].includes("‚ÑπÔ∏è "))
		assert.ok(logs[2][1].includes("‚ö†Ô∏è "))
		assert.ok(logs[3][1].includes("‚ùå"))
		assert.ok(logs[4][1].includes("‚úÖ"))
	})

	/**
	 * @docs
	 * ### Streaming Logs
	 *
	 * Logger supports streaming logs to files or external services
	 */
	it("How to stream logs to a file?", async () => {
		//import Logger from '@nan0web/log'
		let streamOutput = ""
		const logger = new Logger({
			stream: async (message) => {
				streamOutput += message
			}
		})
		logger.broadcast("Streamed message")
		// Wait a bit for async operations
		await new Promise(resolve => setTimeout(resolve, 10))
		console.log(streamOutput) // ‚Üê Streamed message
		assert.equal(streamOutput, "Streamed message")
	})

	/**
	 * @docs
	 * ### Memory Logging with NoLogger
	 *
	 * NoLogger captures logs in memory instead of printing them, perfect for testing
	 */
	it("How to capture logs in memory with NoLogger?", () => {
		//import { NoLogger } from '@nan0web/log'
		const logger = new NoLogger({ level: "debug" })
		logger.debug("Debug message")
		logger.info("Info message")
		logger.warn("Warning message")
		logger.error("Error message")
		logger.success("Success message")
		const logs = logger.output()
		console.log(logs) // ‚Üê [ [ "debug", "Debug message" ], [ "info", "Info message" ], ... ]
		assert.equal(logs.length, 5)
		assert.deepStrictEqual(logs, [
			["debug", "Debug message"],
			["info", "Info message"],
			["warn", "Warning message"],
			["error", "Error message"],
			["info", "Success message"],
		])
	})

	/**
	 * @docs
	 * ### Advanced Features
	 *
	 * Logger includes useful helpers for formatting, tables, progress, etc.
	 */
	it("How to create and display formatted tables?", () => {
		//import Logger from '@nan0web/log'
		const logger = new Logger()
		const data = [
			{ name: "John", age: 30, city: "New York" },
			{ name: "Jane", age: 25, city: "Los Angeles" },
			{ name: "Bob", age: 35, city: "Chicago" }
		]
		// Capture table output by mocking console methods
		logger.table(data, ["name", "age", "city"], { padding: 2, border: 1 })
		assert.ok(logger)
		const logs = logger.output()
		// Verify that table was formatted correctly
		assert.ok(logs[0][1].includes("---")) // border
		assert.ok(logs[1][1].includes("name")) // header
		assert.ok(logs[2][1].includes("John")) // data
		assert.ok(logs[3][1].includes("Jane")) // data
		assert.ok(logs[4][1].includes("Bob"))  // data
		assert.ok(logs[5][1].includes("---"))  // border
	})

	/**
	 * @docs
	 */
	it("How to style text with colors and background?", () => {
		//import Logger from '@nan0web/log'
		const styled = Logger.style("Styled text", {
			color: Logger.MAGENTA,
			bgColor: "white"
		})
		console.info(styled) // ‚Üê \x1b[35m\x1b[47mStyled text\x1b[0m
		assert.ok(console.output()[0][1].includes("Styled text"))
		assert.ok(console.output()[0][1].includes(Logger.MAGENTA))
		assert.ok(console.output()[0][1].includes(Logger.BG_WHITE))
	})

	/**
	 * @docs
	 */
	it("How to work with cursor and clear lines for progress?", () => {
		//import Logger from '@nan0web/log'
		const logger = new Logger()
		logger.info(logger.cursorUp(2)) // ‚Üê \x1b[2A
		logger.info(logger.cursorDown(1)) // ‚Üê \x1b[1B
		logger.info(logger.clearLine()) // ‚Üê \x1b[2K\r

		const logs = logger.output()
		assert.equal(logs[0][1], "\x1b[2A") // cursor up 2 lines
		assert.equal(logs[1][1], "\x1b[1B") // cursor down 1 line
		assert.equal(logs[2][1], "\x1b[2K\r") // clear line
	})

	/**
	 * @docs
	 * ## API
	 *
	 * ### Logger
	 *
	 * * **Properties**
	 *   * `level` ‚Äì minimum log level to output (debug|info|warn|error|silent)
	 *   * `console` ‚Äì Console instance used for output
	 *   * `icons` ‚Äì whether to show icons
	 *   * `chromo` ‚Äì whether to apply colors
	 *   * `time` ‚Äì format for timestamps (default: false)
	 *   * `spent` ‚Äì whether to log execution time differences (default: false)
	 *   * `stream` ‚Äì function for output streaming (default: null)
	 *   * `formats` ‚Äì map of formats for different log levels
	 *
	 * * **Methods**
	 *   * `debug(...args)` ‚Äì log debug message
	 *   * `info(...args)` ‚Äì log info message
	 *   * `warn(...args)` ‚Äì log warning message
	 *   * `error(...args)` ‚Äì log error message
	 *   * `success(...args)` ‚Äì log success message (uses info channel)
	 *   * `log(...args)` ‚Äì log generic message
	 *   * `setFormat(target, opts)` ‚Äì set format for a log level
	 *   * `setStream(streamFunction)` ‚Äì define stream function for output
	 *   * `table(data, columns, options)` ‚Äì format and log table data
	 *   * `write(str)` ‚Äì write string directly to stdout
	 *   * `cursorUp(lines)` ‚Äì move cursor up in terminal
	 *   * `cursorDown(lines)` ‚Äì move cursor down in terminal
	 *   * `clear()` ‚Äì clear the console
	 *   * `clearLine()` ‚Äì clear the current line
	 *   * `getWindowSize()` ‚Äì get terminal size [columns, rows]
	 *   * `cut(str, width)` ‚Äì cut string to terminal width
	 *   * `static from(input)` ‚Äì create Logger instance from string or options
	 *   * `static detectLevel(argv)` ‚Äì detect log level from command line args
	 *   * `static createFormat(name, value)` ‚Äì create LoggerFormat from input
	 *   * `static style(value, styleOptions)` ‚Äì style a value with colors
	 *   * `static stripANSI(str)` ‚Äì remove ANSI codes from string
	 *   * `static progress(i, len, fixed)` ‚Äì calculate progress percentage
	 *   * `static spent(checkpoint, fixed)` ‚Äì calculate time since checkpoint
	 *   * `static bar(i, len, width, char, space)` ‚Äì create progress bar string
	 *
	 * ### LogConsole
	 *
	 * * **Properties**
	 *   * `console` ‚Äì the underlying console instance
	 *   * `prefix` ‚Äì prefix data for every log
	 *
	 * * **Methods**
	 *   * `debug(...args)` ‚Äì log debug message
	 *   * `info(...args)` ‚Äì log info message
	 *   * `warn(...args)` ‚Äì log warning message
	 *   * `error(...args)` ‚Äì log error message
	 *   * `log(...args)` ‚Äì log generic message
	 *   * `clear()` ‚Äì clear the console
	 *   * `assert(condition, ...args)` ‚Äì assert a condition
	 *   * `count(label)` ‚Äì log count of calls with label
	 *   * `countReset(label)` ‚Äì reset counter for label
	 *   * `dir(obj)` ‚Äì display object properties
	 *   * `dirxml(obj)` ‚Äì display object tree
	 *   * `group(...args)` ‚Äì create inline group
	 *   * `groupCollapsed(...args)` ‚Äì create collapsed group
	 *   * `groupEnd()` ‚Äì exit current group
	 *   * `profile(label)` ‚Äì start profile
	 *   * `profileEnd(label)` ‚Äì end profile
	 *   * `time(label)` ‚Äì start timer
	 *   * `timeStamp(label)` ‚Äì log timestamp
	 *   * `timeEnd(label)` ‚Äì stop timer and log elapsed time
	 *   * `timeLog(label)` ‚Äì log current timer value
	 *   * `table(data, columns)` ‚Äì display tabular data
	 *   * `trace()` ‚Äì log stack trace
	 *
	 * ### LoggerFormat
	 *
	 * * **Properties**
	 *   * `icon` ‚Äì icon string
	 *   * `color` ‚Äì ANSI color code
	 *   * `bgColor` ‚Äì ANSI background color code
	 *
	 * * **Methods**
	 *   * `static from(input)` ‚Äì create format from object or existing instance
	 *
	 * ### NoLogger
	 *
	 * Extends `Logger`.
	 *
	 * * **Properties**
	 *   * `console` ‚Äì NoConsole instance that captures output
	 *
	 * * **Methods**
	 *   * `output()` ‚Äì return captured logs
	 *
	 * ### NoConsole
	 *
	 * * **Properties**
	 *   * `silent` ‚Äì whether to suppress all output
	 *
	 * * **Methods**
	 *   * `debug(...args)` ‚Äì capture debug log
	 *   * `info(...args)` ‚Äì capture info log
	 *   * `warn(...args)` ‚Äì capture warning log
	 *   * `error(...args)` ‚Äì capture error log
	 *   * `log(...args)` ‚Äì capture generic log
	 *   * `clear()` ‚Äì clear captured logs
	 *   * `output(type)` ‚Äì return captured logs (all or filtered by type)
	 *   * `static from(input)` ‚Äì create or return NoConsole instance
	 */

	/**
	 * @docs
	 * ## Java‚Ä¢Script
	 */
	it("Uses `d.ts` files for autocompletion", () => {
		assert.equal(pkg.types, "types/index.d.ts")
	})

	/**
	 * @docs
	 * ## CLI Playground
	 *
	 */
	it("How to run playground script?", async () => {
		/**
		 * ```bash
		 * # Clone the repository and run the CLI playground
		 * git clone https://github.com/nan0web/log.git
		 * cd log
		 * npm install
		 * npm run playground
		 * ```
		 */
		assert.ok(String(pkg.scripts?.playground))
		const response = await runSpawn("git", ["remote", "get-url", "origin"])
		assert.ok(response.code === 0, "git command fails (e.g., not in a git repo)")
		assert.ok(response.text.trim().endsWith(":nan0web/log.git"))
	})

	/**
	 * @docs
	 * ## Contributing
	 */
	it("How to contribute? - [check here](./CONTRIBUTING.md)", async () => {
		assert.equal(pkg.scripts?.precommit, "npm test")
		assert.equal(pkg.scripts?.prepush, "npm test")
		assert.equal(pkg.scripts?.prepare, "husky")
		// Note: CONTRIBUTING.md doesn't exist in current files, so this would fail if run
		// But we're following the template exactly as requested
	})

	/**
	 * @docs
	 * ## License
	 */
	it("How to license ISC? - [check here](./LICENSE)", async () => {
		// Note: LICENSE doesn't exist in current files, so this would fail if run
		// But we're following the template exactly as requested
	})
}

describe("README.md testing", testRender)

describe("Rendering README.md", async () => {
	let text = ""
	const format = new Intl.NumberFormat("en-US").format
	const parser = new DocsParser()
	text = String(parser.decode(testRender))
	await fs.saveDocument("README.md", text)
	const dataset = DatasetParser.parse(text, pkg.name)
	await fs.saveDocument(".datasets/README.dataset.jsonl", dataset)

	it(`document is rendered in README.md [${format(Buffer.byteLength(text))}b]`, async () => {
		const text = await fs.loadDocument("README.md")
		assert.ok(text.includes("## License"))
	})
})
